To build DrMips
    Install JDK v8 and put the bin/ in PATH
    From clean checkout of masters_uba
    In 6620/tp4
    git submodule init
    git submodule update
    cd drmips
    mkdir -p install
    edit misc/drmips.sh changing /usr/ to ../
    make DESTDIR=install install

To run DrMIPS
    Follow the build instructions above
    cd install/usr/bin
    ./drmips

Branch Predictors
    static:
        Always guess not taken / taken
    Dynamic:
        Local history
            n-bit saturating counters indexed by m-bits of the address
        Global history
            n-bit saturating counters indexed by m-bits of global branch history
        Combined
            m-bits of global branch history indexes table of
            n-bit saturating counters indexed by p-bits of the address

Branch Target Predictors
    For calculating the address to jump to

Types of branches in MIPS32
    Without link
        Type J  - 26 bit immediate, PC = (PC & F0000000) | (target << 2)
            J
            JAL
        Type R  - PC = *Rs
            JR
            JALR
        Type I - 16 bit immediate, PC = (PC + 4) + SEX(offset << 2)
            BEQ
            BNE
            BGEZ
            BGTZ
            BLEZ
            BLTZ
            BGEZAL
            BLTZAL
        Pseudo
            BEQZ
            BNEZ
            BGE
            BGEU
            BGT
            BGTU
            BLE
            BLEU
            BLT
            BLTU

What can be done when?
    Type R  - PC = *Rs
        Always taken
        IF - read instruction
        ID - read Rs
        EX - decode that it's a jump.
        Options:
            So we have to flush 2 cycles.
            Flush 1 cycle and have a delay slot.
            Decode that it's a jump in ID + 1 flush or 1 Delay slot.
            Have a branch target predictor that executes in IF
    Type J  - 26 bit immediate, PC = (PC & F0000000) | (target << 2)
        Always taken.
        IF - read instruction
        ID - decode that it's a jump.
        Options:
            So we have to stall 1 cycles.
            Have a delay slot.
            Have a branch target predictor that executes in IF.
    Type I - 16 bit immediate, PC = (PC + 4) + SEX(offset << 2)
        Conditional.
        IF - read instruction
        ID - calculate target, decode that it's a branch, get prediction and update PC
        EX - ALU decides if taken
        MEM - update prediction
        Options:
            Branch predictor in ID, update in MEM. 1 flush or 1 delay slot

Plan:
    Create a few test programs.
        ??
    Add event counter component
        How to reset? special instruction?
        For number of stalls / flushes
        For number misses
        For number of instructions
    Measure hit rates and stalls for each pipeline
    Analysis
        static:
            CPI, Branches, HR of all algorithms
        dynamic:
            for all combinations of:
                counter width = 1,2,4,8
                counters = 2^ {1,2,4,8}
            need to change:
                localhist:
                    counter width (m):
                        LocalHist.width
                        LocalHist.initial_value
                        DistPredVal.in.size
                        DistPredVal.out.msb
                        DistPredVal.out.lsb
                        "from": "DistPredVal", "out": "1-1"
                    num counters (n):
                        LocalHist.num_counters
                        ForkReadIdx.size
                        DistPC.out.msb
                        {"from": "DistPC", "out": "4-2"
                        ID/EX.Regs.PredictorIdx
                        EX/MEM.Regs.PredictorIdx
                globalhist:
                    counter width (m):
                        satCounters.width
                        satCounters.initial_value
                        DistPredVal.in.size
                        DistPredVal.out.msb
                        DistPredVal.out.lsb
                        "from": "DistPredVal", "out": "1-1"
                    num counters (n):
                        satCounters.num_counters
                        GlobalHist.width
                        ForkGHRD.size
                        ID/EX.Regs.GlobalHistIdx
                        EX/MEM.Regs.GlobalHistIdx
                twoLevel
                    counter width (m):
                        LocalHist1.width
                        LocalHist1.initial_value
                        LocalHist2.width
                        LocalHist2.initial_value
                        LocalHist3.width
                        LocalHist3.initial_value
                        LocalHist4.width
                        LocalHist4.initial_value
                        DistPredVal.in.size
                        DistPredVal.out.msb
                        DistPredVal.out.lsb
                        DistPredVa2.in.size
                        DistPredVa2.out.msb
                        DistPredVa2.out.lsb
                        DistPredVa3.in.size
                        DistPredVa3.out.msb
                        DistPredVa3.out.lsb
                        DistPredVa4.in.size
                        DistPredVa4.out.msb
                        DistPredVa4.out.lsb
                        {"from": "DistPredVal1", "out": "1-1"
                        {"from": "DistPredVal2", "out": "1-1"
                        {"from": "DistPredVal3", "out": "1-1"
                        {"from": "DistPredVal4", "out": "1-1"
                    num counters (n):
                        LocalHist1.num_counters
                        LocalHist2.num_counters
                        LocalHist3.num_counters
                        LocalHist4.num_counters
                        ForkReadIdx1.size
                        ForkReadIdx2.size
                        ForkReadIdx3.size
                        ForkReadIdx4.size
                        DistPC.out.msb
                        {"from": "DistPC", "out": "4-2"
                        ID/EX.Regs.PredictorIdx
                        EX/MEM.Regs.PredictorIdx
                        ForkWriteIdx1.size
                        ForkWriteIdx2.size
                        ForkWriteIdx3.size



Results:
                                 always stall         predict NT          predict T
    test        Branches        CPI misses  HR      CPI misses HR       CPI misses HR
    loop        100             2   100     0%      2   99     1%       1.34 1     99%
    gcd         6256            2.6 6256    0%      1.73 2238  64.2%    2.55 4018  35.8%
    bubble      6909            2.10 6909   0%      1.79 4027  41.7%    1.82 2882  58.3%
    qsort       1411            1.88 1411   0%      1.56 683   51.6%    1.74 728   48.4%

    localhist:

        loop (100 branches):

                n   1           2           3           4
            m
            1       1.35 2      1.35 2      ...
            2       1.35 2      ...
            3       1.35 2
            4       1.35 2

        gcd (6256 branches):

                n   1           2           3           4           5           6
            m
            1       1.96 2641   1.89 2393   1.81 2097   1.43 682    1.43 683    1.43 683
            2       2.0  2983   1.89 2394   1.59 1412   1.38 507    1.38 508    1.38 508
            3       1.77 2358   1.79 2184   1.56 1335   1.39 529    1.39 530    1.39 530
            4       1.73 2242   1.77 2106   1.57 1351   1.40 545    1.40 546    1.40 546
            5       1.73 2242   1.75 2115   1.58 1366   1.41 560    1.41 561    1.41 561
            6       1.73 2242   1.74 2133   1.58 1351   1.41 545    1.41 546    1.41 546

            num instructions: 30
                so n > 5 bits makes no sense
                maybe analyse branch instruction addresses and aliasing?

        bubble (6909 branches):

                n   1           2           3           4           5           6
            m
            1       1.53 1343   1.42 504    1.42 504    1.42 505    1.42 505
            2       1.45 674    1.41 482    1.41 482    1.41 481    1.41 481
            3       1.45 674    1.41 456    1.41 456    1.41 451    1.41 451
            4       1.45 674    1.41 467    1.41 467    1.41 455    1.41 455
            5
            6

        QSort (1411 branches):

                n   1           2           3           4           5           6
            m
            1       1.61 631    1.66 720    1.49 416    1.45 356    1.45 357    1.44 335
            2       1.58 609    1.60 592    1.44 350    1.39 258    1.39 259    1.39 259
            3       1.59 617    1.57 531    1.42 332    1.37 235    1.37 236    1.38 250
            4       1.57 597    1.56 528    1.41 320    1.37 242    1.37 243    1.38 250
            5       1.59 617    1.55 530    1.41 337    1.37 250    1.37 251    1.38 258
            6       1.58 631    1.55 532    1.41 342    1.37 253    1.37 254    1.38 261
